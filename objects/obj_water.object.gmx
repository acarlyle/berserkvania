<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_water</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-999</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Setup
/*
 You can also set all these variables in the creation code of the
 instance in the room editor for more customized water bodies.
*/
/*color = merge_color(c_blue,c_aqua,.3); //The color of the water.
image_alpha = .4; //The density/see-thoughness of the water.

glimmer = false; //If you want the top waves to glimmer.
nodes = ceil((sprite_width)/4); //More nodes = more realistic, but also slower.
smoothness = 3; //How much to smooth out the waves.
disturbance = 1; //How disturbed the water should be.
wave_max = sprite_height; //The maximum wave height and depth.
solids = obj_solid; //Set to -1 if you have no solid objects (preferably a parent).
damp = 0; //Damping of the oscillation
freq = 8; //Oscillations per second
time = .2; //Time step

/*
 Every node needs a y-position (wY) and a vertical speed (vspd).
 These will be put in an array.
*/
/*
for(var i=nodes;i&gt;0;i--){
 ypos[i-1] = 0;
 vspd[i-1] = 0;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/*///Update node count
if nodes != array_length_1d(ypos) {
 ypos = 0;
 vspd = 0;
 for(var i=nodes;i&gt;0;i--){
  ypos[i-1] = 0;
  vspd[i-1] = 0;
 }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/*///Update water
var __ndist = (sprite_width/max(1,nodes-1)); //The distance between the nodes.
//Toggle off mask to interact with other bodies of water
with obj_water {
 mask_index = -1; 
}

//Here we add random disturbance to the water, by adding to random nodes' vertical speed.
repeat(disturbance*image_xscale) {
 vspd[irandom_range(1,nodes-1)] += choose(.1,-.1);
}

//Smooth out vspd values
vspd = array_smooth_1d(vspd,(smoothness-1)/2)

//Updating the nodes' vertical speed and y position through a loop.
for(var i=0;i&lt;nodes;i++){
 //If we are working with the end nodes, or if the water nodes is below other water or solids, we want them to stand still.
 if i == nodes-1 || i == 0 || position_meeting(x+i*__ndist,y-1,obj_water) {
  ypos[i] = 0;
 } else {
  var __r = numeric_springing(ypos[i],vspd[i],0,damp,freq,time);
  ypos[i] = __r[0];
  vspd[i] = __r[1];
 }
 ypos[i] = median(min(wave_max,sprite_height),ypos[i],-wave_max); //We limit this to be withing out wave_max range (and no deeper than our sprite is tall).
 
 //We then force down water touching with solids or water above itself
 while ypos[i] &lt; 0 &amp;&amp; (collision_line(x+i*__ndist,y+ypos[i],x+i*__ndist,y,obj_water,false,true) || collision_line(x+i*__ndist,y+ypos[i],x+i*__ndist,y,solids,false,true)) {
  ypos[i]++;
 }
}

//Toggle on mask again
with obj_water {
 mask_index = mask_water;
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/*///Collisions
var __ndist = (sprite_width/max(1,nodes-1)), __id, __array = 0; //The distance between the nodes.
//Collisions with the water surface
for(var i=1;i&lt;nodes;i++){
 do {
  //Find instance of collision
  __id = collision_line(x+(i-1)*__ndist,y+ypos[i-1],x+i*__ndist,y+ypos[i],all,false,true);
  with __id {
   is_water_surface_collision = true; //A special accessor variable
   //Add it to the array
   if is_array(__array) {
    __array[array_length_1d(__array)] = id;
   } else {
    __array[0] = id;
   }
   //Move away temporarily
   y -= 99999;
  }
 } until __id = noone;
}
//Collisions with the water body
for(var i=1;i&lt;nodes;i++){
 do {
  //Find instance of collision
  __id = collision_rectangle(x+(i-1)*__ndist,y+mean(ypos[i-1],ypos[i]),x+i*__ndist,y+sprite_height,all,false,true);
  with __id {
   is_water_surface_collision = false; //A special accessor variable
   //Add it to the array
   if is_array(__array) {
    __array[array_length_1d(__array)] = id;
   } else {
    __array[0] = id;
   }
   //Move away temporarily
   y -= 99999;
  }
 } until __id = noone;
}
//Move instances back and perform collision events
if is_array(__array) {
 for(var i=0;i&lt;array_length_1d(__array);i++){
  with __array[i] {
   y += 99999;
   event_perform(ev_collision,other.object_index);
  }
 }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="4" ename="obj_player">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (!obj_player.m_underwater){
    //show_debug_message("ENGAGE UNDERWATER SEQUENCE");
    
    obj_player.m_underwater = true;  
    obj_player.m_jumpSpeed -= 2; 
    obj_player.m_moveSpeed -= 1; 
} 
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>draw_self();

/*///Draw water
var __ndist = (sprite_width/max(1,nodes-1)); //The distance between the nodes.
//We draw the water as a primitive, which allows us to make a more complex shape.
draw_set_color(color);
draw_primitive_begin(pr_trianglestrip);
for(var i=0;i&lt;nodes;i++){
 draw_set_alpha(image_alpha);
 draw_vertex(x+i*__ndist,y+sprite_height); //Here we are making trangles going from the bottom..
 draw_vertex(x+i*__ndist,y+ypos[i]); //..to the wave tops!
}
draw_primitive_end();

//If we want a glimmering surface, then we need to draw this as well! (almost in the same way).
if glimmer {
 draw_set_color(c_white);
 draw_primitive_begin(pr_trianglestrip);
 //We draw a 1 pixel thik line, with fading alpha depending on the wave height.
 for(var i=0;i&lt;nodes;i++){
  draw_set_alpha(0);
  draw_vertex(x+i*__ndist,y+ypos[i]+1);
  draw_set_alpha(-ypos[i]*10);
  draw_vertex(x+i*__ndist,y+ypos[i]);
 }
 draw_primitive_end();
}

//And always reset the alpha!
draw_set_alpha(1);
*/

</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
